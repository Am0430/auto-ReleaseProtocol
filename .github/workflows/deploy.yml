name: 通用部署多协议到S3

on:
  push:
    paths:
      - 'source/*.html'  # 监听source目录下所有html文件的修改（可根据需要调整）

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: 拉取代码
        uses: actions/checkout@v4

      - name: 配置AWS凭证
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: cn-northwest-1  # 替换为你的S3区域

      - name: 定义文件映射表并提取本次修改的文件
        id: file_mapping
        run: |
          # ********** 核心：维护这个映射表即可，新增文件时在这里添加 **********
          FILE_MAPPING='{
            "source/yunmu13-dataprivicyprotocol.html": "yunmu13-datapriviprotocol.html",
            "source/yunmu13-useragreement.html": "yunmu13-useragreement.html",
            # 示例：新增的服务协议
          }'
          echo "FILE_MAPPING=$FILE_MAPPING" >> $GITHUB_ENV

          # 获取本次提交修改的文件列表（相对路径）
          MODIFIED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
          echo "MODIFIED_FILES=$MODIFIED_FILES" >> $GITHUB_ENV

          # 筛选出映射表中存在的、且本次被修改的文件，存入数组
          MODIFIED_TARGET_FILES=$(echo "$MODIFIED_FILES" | grep -f <(echo "$FILE_MAPPING" | jq -r 'keys[]') | tr '\n' ' ')
          echo "MODIFIED_TARGET_FILES=$MODIFIED_TARGET_FILES" >> $GITHUB_OUTPUT

      - name: 循环处理每个修改的协议文件
        if: steps.file_mapping.outputs.MODIFIED_TARGET_FILES != ''
        run: |
          # 遍历每个被修改的源文件
          for SOURCE_FILE in ${{ steps.file_mapping.outputs.MODIFIED_TARGET_FILES }}; do
            echo "开始处理文件：$SOURCE_FILE"
            
            # 从映射表中获取对应的S3目标文件名
            S3_FILENAME=$(echo "$FILE_MAPPING" | jq -r --arg key "$SOURCE_FILE" '.[$key]')
            if [ -z "$S3_FILENAME" ] || [ "$S3_FILENAME" == "null" ]; then
              echo "警告：文件$SOURCE_FILE未在映射表中配置，跳过处理"
              continue
            fi

            # 生成备份文件名（带时间戳）
            BACKUP_FILENAME="${S3_FILENAME%.html}_$(date +%Y/%m/%d/%H:%M).html"
            S3_BUCKET_PATH="s3://test-autoreleaseprotocol/mp/"  # 你的S3桶路径

            # 步骤1：备份S3中现有的协议文件（不存在则忽略错误）
            echo "备份旧文件：$S3_BUCKET_PATH/$S3_FILENAME → $S3_BUCKET_PATH/backup/$BACKUP_FILENAME"
            aws s3 cp "$S3_BUCKET_PATH/$S3_FILENAME" "$S3_BUCKET_PATH/backup/$BACKUP_FILENAME" --acl public-read || true

            # 步骤2：上传最新文件到S3指定路径
            echo "上传新文件：$SOURCE_FILE → $S3_BUCKET_PATH/$S3_FILENAME"
            aws s3 cp "$SOURCE_FILE" "$S3_BUCKET_PATH/$S3_FILENAME" --acl public-read

            # 步骤3：刷新CloudFront缓存
            echo "刷新CloudFront缓存：/mp/agreements/$S3_FILENAME"
            aws cloudfront create-invalidation \
              --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
              --paths "/mp/agreements/$S3_FILENAME"
            
            echo "文件$SOURCE_FILE处理完成"
            echo "-------------------------"
          done
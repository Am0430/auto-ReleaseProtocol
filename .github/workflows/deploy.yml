name: 部署协议文件到S3

on:
  push:
    paths:
      - 'source/yunmu13-useragreement.html'  # 只有当源文件更新时触发
      - 'source/yunmu13-dataprivicyprotocol.html' # 云祭扫隐私协议
      - 'source/yxt-useragreement.html' # 园信通用户协议
      - 'source/yxt-dataprivicyprotocol.html' # 园信通隐私协议
    

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: 拉取代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: 提取文件（修复文件名映射+备份名逻辑）
        id: extract_filename
        run: |
          # 1. 获取本次修改的本地文件
          CHANGED_FILES=$(git diff --name-only HEAD^..HEAD | grep '^source/.*\.html$')
          CHANGED_FILE=$(echo "$CHANGED_FILES" | head -n 1)
          if [ -z "$CHANGED_FILE" ]; then
            echo "错误：未找到source下的html文件！"
            exit 1
          fi
          echo "本地修改文件：$CHANGED_FILE"

          # 2. 提取S3目标文件名（与本地文件名完全一致，比如source/yunmu13-dataprivicyprotocol.html → yunmu13-dataprivicyprotocol.html）
          HTML_FILENAME=$(basename "$CHANGED_FILE")
          if [ -z "$HTML_FILENAME" ]; then
            echo "错误：文件名提取失败！"
            exit 1
          fi
          echo "S3目标文件名：$HTML_FILENAME"

          # 3. 生成备份文件名（正确格式：原文件名_时间戳.html，比如yunmu13-dataprivicyprotocol_2025-12-16-15-30.html）
          BACKUP_FILENAME="${HTML_FILENAME%.html}_$(date +%Y-%m-%d-%H-%M).html"
          echo "备份文件名：$BACKUP_FILENAME"

          # 写入环境变量
          echo "local_file=$CHANGED_FILE" >> $GITHUB_ENV
          echo "s3_target_file=$HTML_FILENAME" >> $GITHUB_ENV
          echo "s3_backup_file=$BACKUP_FILENAME" >> $GITHUB_ENV
          echo "cloudfront_path=/mp/agreements/$HTML_FILENAME" >> $GITHUB_ENV

      - name: 配置AWS凭证
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: cn-northwest-1

      - name: 备份S3原始文件（修复：先检查原始文件是否存在，再备份）
        run: |
          # 检查S3中原始文件是否存在
          if aws s3 ls "s3://test-autoreleaseprotocol/mp/${{ env.s3_target_file }}" >/dev/null 2>&1; then
            # 存在则备份
            aws s3 cp "s3://test-autoreleaseprotocol/mp/${{ env.s3_target_file }}" \
              "s3://test-autoreleaseprotocol/mp/backup/${{ env.s3_backup_file }}" \
              --acl public-read
            echo "已备份原始文件到backup/${{ env.s3_backup_file }}"
          else
            # 不存在则跳过备份（避免生成空文件）
            echo "S3中原始文件不存在，跳过备份"
          fi

      - name: 上传文件（覆盖S3原始文件）
        run: |
          # 本地文件 → S3目标路径（直接覆盖）
          aws s3 cp "${{ env.local_file }}" \
            "s3://test-autoreleaseprotocol/mp/${{ env.s3_target_file }}" \
            --acl public-read
          echo "已上传最新文件到S3：${{ env.s3_target_file }}"

      - name: 刷新CloudFront缓存
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "${{ env.cloudfront_path }}"